-- Copyright 2019, Mansour Moufid <mansourmoufid@gmail.com>

local libnu = {}

local ffi = require('ffi')
local math = require('math')
local nu = ffi.load('nu')

ffi.cdef([[
{{nu.h}}
]])

libnu.float = 'float'
libnu.complex = 'nu_complex'

local array = {}

function array.alloc(ctype, n)
    return nu.nu_array_alloc(n, ffi.sizeof(ctype))
end

function array.gc(x)
    return ffi.gc(x, nu.nu_array_free)
end

function array.new(ctype, n)
    local ptr = array.alloc(ctype, n)
    if ptr == nil then
        return nil
    end
    local a = ffi.cast(ctype .. ' *', ptr)
    return array.gc(a)
end

function array.reverse(x, n)
    local m = math.floor(n / 2)
    for i = 0, m - 1 do
        local tmp = x[i]
        x[i] = x[n - 1 - i]
        x[n - 1 - i] = tmp
    end
end

function array.zero(x, n)
    if ffi.typeof(x) == ffi.typeof('nu_complex *') then
        for i = 0, n - 1 do
            x[i].r = 0
            x[i].i = 0
        end
    else
        for i = 0, n - 1 do
            x[i] = 0
        end
    end
end

local function scalar(cfunction)
    return function(x, n)
        if x == nil then
            error('nil argument', 2)
        end
        if n == 0 then
            error('zero size argument', 2)
        end
        return tonumber(cfunction(x, n))
    end
end

local function binary(cfunction)
    return function(z, x, y, n)
        if z == nil or x == nil or y == nil then
            error('nil argument', 2)
        end
        cfunction(z, x, y, n)
    end
end

local function unary(cfunction)
    return function(z, x, n)
        if z == nil or x == nil then
            error('nil argument', 2)
        end
        cfunction(z, x, n)
    end
end

local function tuple(cfunction)
    return function(x, n)
        if x == nil then
            error('nil argument', 2)
        end
        local z = cfunction(x, n)
        local a = z.a
        local b = z.b
        return tonumber(a), tonumber(b)
    end
end

array.argmax = scalar(nu.nu_array_argmax)

array.argmin = scalar(nu.nu_array_argmin)

array.max = scalar(nu.nu_array_max)

array.min = scalar(nu.nu_array_min)

array.add = binary(nu.nu_array_add)

array.mul = binary(nu.nu_array_mul)

array.cadd = binary(nu.nu_array_cadd)

array.cmul = binary(nu.nu_array_cmul)

array.conj = unary(nu.nu_array_conj)

array.cos = unary(nu.nu_array_cos)

array.exp = unary(nu.nu_array_exp)

array.log = unary(nu.nu_array_log)

array.sin = unary(nu.nu_array_sin)

function array.linspace(x, start, stop, n)
    if x == nil then
        error('nil argument', 2)
    end
    nu.nu_array_linspace(x, start, stop, n)
end

local sum = {}

sum.sum = scalar(nu.nu_sum)

sum.meanvar = tuple(nu.nu_meanvar)

libnu.array = array
libnu.sum = sum
return libnu
